import { NextResponse } from "next/server";
import { authOptions } from "@/lib/auth";
import { getServerSession } from "next-auth";
import { getSessionContext, requireRole } from "@/lib/rbac";
import { prisma } from "@/lib/prisma";
import { z } from "zod";

const Body = z.object({ templateId: z.string().min(1) });

export async function POST(req: Request) {
  const session = await getServerSession(authOptions);
  if (!session) return NextResponse.json({ error: "UNAUTHORIZED" }, { status: 401 });
  try {
    requireRole(session, ["admin", "editor"]);
  } catch {
    return NextResponse.json({ error: "FORBIDDEN" }, { status: 403 });
  }
  const parsed = Body.safeParse(await req.json());
  if (!parsed.success) return NextResponse.json({ error: parsed.error.flatten() }, { status: 422 });

  const tpl = await prisma.template.findUnique({ where: { id: parsed.data.templateId } });
  if (!tpl) return NextResponse.json({ error: "NOT_FOUND" }, { status: 404 });
  const payload = tpl.payload as any;

  // Clone cards/contents/collections; new IDs will be generated by DB
  const createdContents = await prisma.$transaction(
    (payload.contents ?? []).map((c: any) =>
      prisma.contentPiece.create({ data: { title: c.title, kind: c.kind, body: c.body, mediaUrl: c.mediaUrl, metadata: c.metadata as any, tags: c.tags as any, createdById: (session.user as any).id } })
    )
  );
  const contentsIdMap = new Map(payload.contents?.map((c: any, i: number) => [c.id, createdContents[i].id] as const));
  const createdCollections = await prisma.$transaction(
    (payload.collections ?? []).map((col: any) =>
      prisma.collection.create({ data: { title: col.title, description: col.description, itemIds: (col.itemIds ?? []).map((id: string) => contentsIdMap.get(id) ?? id) as any, tags: col.tags as any, createdById: (session.user as any).id } })
    )
  );
  const collectionsIdMap = new Map(payload.collections?.map((c: any, i: number) => [c.id, createdCollections[i].id] as const));

  const maxOrder = await prisma.card.aggregate({ _max: { order: true } });
  let orderStart = (maxOrder._max.order ?? 0) + 1;
  await prisma.$transaction(
    (payload.cards ?? []).map((k: any, idx: number) =>
      prisma.card.create({
        data: {
          title: k.title,
          description: k.description,
          type: k.type,
          contentId: k.contentId ? contentsIdMap.get(k.contentId) ?? null : null,
          collectionId: k.collectionId ? collectionsIdMap.get(k.collectionId) ?? null : null,
          icon: k.icon,
          layout: k.layout as any,
          order: orderStart + idx,
          visible: k.visible ?? true,
          createdById: (session.user as any).id,
        },
      })
    )
  );

  return NextResponse.json({ ok: true });
}


